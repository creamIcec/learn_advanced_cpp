宏的概念我们之前有所接触，但在实际应用中很少使用。在平时，个人用到它的情况很少，只有:

- 在避免重复包含一个头文件的时候
- 定义一些简单函数的时候，下面将提到一个例子

但事实上，我们看各个大型C++项目的源代码会发现，使用宏的场景不仅不少，而且用法也是多种多样。这说明在实际生产中，宏的作用比我们之前认为的大得多。

*注意: 本篇中提到的宏(MACROS)容易和预处理指令(Preprocessor)混淆。宏指的是使用`#define`预处理指令给一个字符串起的名字, 而预处理指令指的是`#`开头的各个指令本身。例如:*

```c++
#define PI 3.14159
```

*中, `#define`是一个预处理指令，而`PI`是宏(字符串别名), `3.14159`是该宏的值(字符串)。*
*但不可避免的是, 宏和预处理指令是紧密联系的，因此我们的内容中会多次提到他们一起起作用的时候。*

### 宏可以怎么用?

让我们从几个例子开始。

#### 避免重复包含头文件(我们已知的用途)

如果我们想要避免重复包含头文件，可以使用下面的代码:

```c++
#ifndef __XXX_H__
#define __XXX_H__

//代码主体

#endif
```

这段代码的逻辑可以解释成一个标记的比喻。假设编译器在编译代码的时候整个代码是一本书, 每个文件是书的一页，那么:

1. 编译器翻到了某一页，首先通过`#ifndef`(if not defined, 如果未定义)得知这一页没被标记，说明还没编译；
2. 编译这个文件(代码主体), 同时给这一页加上标记`#define __XXX_H__`，表示看过了;
3. 下次再翻到这一页时(例如后面某一页“参考”了这一页(使用`#include`)), 发现做过了标记, 跳过这个文件的编译。
#### 定义一些简单的常量或函数(我们已知的用途/不推荐/已过时)

例如，我们熟悉的平方宏的定义:

```c++
#define SQUARE(X) ((X) * (X))
```

在后面引用这个宏时:

```c++
int square_of_3 = SQUARE(3);
```

这实际上会被展开:

```c++
int square_of_3 = ((3) * (3));
```

这便是宏是“字符串别名”的含义。
为什么说这种使用宏的方式不推荐呢? 其实原因非常明显，就在这个“字符串别名”上。假设我们换一种定义方式:

```c++
#define SQUARE(X) X * X
```

此时，由于字符替换，如果我们有下面的变量:

```c++
int square_of_an_expression = SQUARE(3 + 3);
```

替换后将会变成:

```c++
int square_of_an_expression = 3 + 3 * 3 + 3;
```

这和我们想象中的计算顺序不一样。本来我们想要得到3+3=6的平方，也就是36, 但字符串直接替换变成了先计算3\*3 = 9, 再加上两个3, 变成了9+3+3=15。
这种错误是由于宏本身的性质导致的，我们没有办法控制，只能修改宏本身的定义，就像上面那样，给所有表达式加上括号。但是，*如果一件事可能出错，那么总有出错的时候*。也就是说，如果不避免宏本身的性质导致的问题，我们总有可能出现错误。

#### 完整的用途: 条件编译

思路打开，宏用在上述避免重复包含头文件的情况下，不就是一种条件编译嘛？也就是说，不止这种情况，我们可以在任何地方使用宏，用来选择性地编译代码。看看下面的例子, 这个例子非常典型，**将宏用于调试环境**。

```c++
Cmd::Cmd()
#if _DEBUG
  : m_state(State::NotExecuted)
#endif
{
}
```

这段代码来自`Aseprite`，一个使用`C++`开发的像素绘画软件。

> 链接: https://github.com/aseprite/aseprite/blob/main/src/app/cmd.cpp
> 代码以MIT协议授权。

这段代码的含义是，当`_DEBUG`宏为`true`时，执行中间的代码。

这个用途对于`C++`这样的编译型语言非常有用。结合预处理指令的特性，即预处理在编译前发生，这种用法解决了一个大问题: 在代码体内，如果我们通过`if`来判断是否是调试环境，代码会变得多余，因为运行环境永远不会触发调试，这个`if`就是多余的。

#### 对宏的一些看法

现在随着C++的现代化，越来越多的宏在被标准替代。宏的本质是非常自由的，但自由的代价是需要非常谨慎地使用，否则将会导致非常严重的错误。

“字符替换”，一个简单的想法，在早期功能不是特别多的时候，用宏来实现一些常用的代码片段非常有用，但随之而来也有错误的风险:

- 相比函数，宏不会做类型检查。宏不知道我们传入的参数的类型，只是将形参字面替换成实参；
- 字符替换本身的特性，决定了它不会像函数那样运行，最典型的例子如我们上面提到的第二个平方操作代码。

综上所述，我认为最适合使用宏的地方就是条件编译。条件编译中，宏仅仅用于标记作用，不参与任何计算，任何逻辑。此时，宏的优势就体现出来了: 简短，在编译前被解释，用于超脱“编译”的操作，做到一些常规代码无法做到的事。