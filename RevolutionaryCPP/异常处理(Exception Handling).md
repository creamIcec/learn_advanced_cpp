### 在C++中处理错误

C++提供大多数语言都具有的错误处理机制，也就是`try catch`机制。`try catch`机制我们都熟悉了，用于"尝试"执行一段代码，在代码中出现错误时(这个错误需要由`throw`扔出)， 通过`catch`获取到这个错误，并做出相应处理，防止程序崩溃。

我们来看一个常见的错误处理: 除0错误。

```c++
#include <stdexcept>  
#include <iostream>    
  
int divide(int a, int b){  
    if(b == 0){  
        throw std::runtime_error("Can't divide by 0!");  
    }  
    return a / b;  
}  
  
int main(){  
  
    try{  
        int num1 = 12;  
        int num2 = 0;  
        int result = divide(num1, num2);  
        std::cout << "result is" << result << std::endl;  
    } catch (const std::runtime_error& e){  
        std::cout << "Error: " << e.what() << std::endl;  
    }  
  
    return 0;  
}
```
在这段代码中，我们可以看到，在`divide`这个功能函数中，由于除数为`0`时是无法执行正常逻辑的，如果没有异常处理机制，我们就没办法继续执行代码。
### 使用异常处理的情况

上面的例子可能会有一个问题: 我们在传入数据之前，用一个`if`判断语句判断是否是`0`不就好了(参考图灵完备性)，为什么需要`try catch`? 下面的情况可能就说明了原因:

- 如果数字由用户(或者其他外部来源)输入，而不是从程序内获取的呢?
- 尝试控制我们预先不知道的外部来源时，我们可能并不知道可能会出什么错。
	- 例如: 尝试连接网络。可能的错误包括连接超时，连接错误，内容无效(参考数量庞大的HTTP错误码)等等情况，这种情况下为每种情况定义一个`if`块会非常麻烦。
- 我们调用外部库时, 此时使用`try catch`就是遵守规范。文档中提供了可能会发生的，通过`throw`抛出的错误，此时我们使用`try catch`来处理错误，可以提高开发效率。

本质上来讲，`try catch`是一种建立在前人经验和外部资源控制之上的规范。这种规范通过定义通用的"错误"来实行，统一错误处理方式，使得我们不需要额外的`if/else`判断。

也正是由于其规范性，我们在使用`try catch`时需要斟酌。一些情况包括:

- 如何定义"异常"? 每个可能出现异常的地方都需要使用`try catch`语句吗?
	- "异常"基本上是上面我们提到的提出`try catch`的原因中提到的异常。通常和外部资源相关，此时使用`try catch`非常合适。
	- 由于代码缺陷的"异常"不适用`try catch`。限定`try catch`只在一个具体领域(例如此处的外部资源)使用可以帮助我们排除自己代码中的固有问题。
- 在使用外部库时，如果库文档给出了可能发生异常的情况，则需要`try catch`妥善处理。
- 在编写和外部资源相关的代码时，我们需要使用`throw`关键字在外部资源发生异常时抛出异常，供调用者处理。

### 进一步研究

#### 为什么C++的`try catch`没有`finally`块?

其实这是我们对于`finally`块的一种误解。之前，我们在使用`finally`块时，通常只会理解为:

> 一段无论是`try`成功结束还是`catch`被触发的情况下都要执行的一段代码。

其实这样的理解不太符合`try catch`的本意。`try catch`通常用于和外部资源交互，如果我们任意使用`try catch`块，此时`finally`就很容易沦为“两个分支的共同部分”。而事实上，外部资源通常需要即时的分配，有分配就需要有对应的回收机制。

所以, `finally`是用来处理回收事务的，回收不管在`try`成功执行的情况下(表示成功访问了资源，现在结束了)还是`catch`被触发的情况下(表示和外部资源的交互过程出现问题)，都应该执行。

在C++中，在栈上分配的外部资源访问对象在退出作用域后会自动触发析构函数。由于存在`RAII`规范(见下文)，析构函数中必须将该对象涉及的所有资源都一一释放。因为`try`带来了一个作用域，所以`try`结束后，其中的栈上分配的外部资源访问对象将在结束之后自动释放，所以我们无需`finally`块。

不过，需要注意的是，堆上分配的资源(例如使用`new`关键字)将不会自动释放，需要手动释放。此时使用`finally`块看似是合理的，但我们使用动态对象去访问外部资源的情况非常少见(毕竟外部资源访问应该是写程序的时候就确定了的吧)，所以仍然没有引入的必要。
##### RAII编程规范(Resource Acquisition is Initialization)

来自Gemini:

RAII (Resource Acquisition Is Initialization) 是 C++ 中一种重要的编程惯用法，它将资源的获取与对象的生命周期绑定在一起，从而实现自动化的资源管理。

核心思想：

    资源获取即初始化： 当对象创建时，就在其构造函数中获取所需的资源（例如内存、文件句柄、锁等）。
    资源释放即析构： 当对象销毁时，就在其析构函数中自动释放已获取的资源。

RAII 的优点：

    自动资源管理： 避免了手动释放资源可能导致的内存泄漏、文件句柄泄露等问题。
    异常安全性： 即使在程序抛出异常的情况下，也能保证资源被正确释放。
    代码简洁性： 简化了资源管理的代码，提高了代码的可读性和可维护性。

RAII 的实现：

RAII 的实现依赖于 C++ 的以下特性：

    对象的生命周期： C++ 对象的生命周期由其作用域决定。
    构造函数和析构函数： 构造函数在对象创建时自动调用，析构函数在对象销毁时自动调用。

RAII 的应用场景：

RAII 广泛应用于 C++ 的各种资源管理场景，例如：

    内存管理： 使用智能指针（如 std::unique_ptr、std::shared_ptr）来自动管理动态分配的内存。
    文件操作： 使用文件流对象（如 std::ifstream、std::ofstream）来自动管理文件句柄。
    锁管理： 使用锁对象（如 std::mutex、std::lock_guard）来自动管理互斥锁。

总结：

RAII 是一种强大的 C++ 编程惯用法，它可以帮助程序员编写更安全、更简洁、更健壮的代码。