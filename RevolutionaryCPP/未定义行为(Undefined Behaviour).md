
未定义行为是会导致未确定的结果的行为，这在C++等内存不安全的语言中非常常见。常见的未定义行为包括下标越界、除零等。
### 为什么要了解这个?

我们可能会觉得，我们在编写代码的时候避免触发未定义行为不就好了? 甚至还会怀疑，真的存在"未定义"的行为吗? 难道不是每一个编译或者运行时错误都有一个"确定"的结果?

其实, 我们确实需要了解它, 因为:

- 有人觉得只要避免触发未定义行为就好: 实际上, 我们确实可以在编写时多加小心, 大概率可以将未定义行为减少到0; 但这并不意味着我们使用的库或外部代码不会触发未定义行为, 或者我们同事编写的代码没有未定义行为。因此, 如果我们了解未定义行为, 一旦别人的代码出现让人困惑(正是因为"未定义", 所以结果的多变才会让人困惑)的bug, 我们可以及时意识到问题并查找可能的方案。
	- 举例说明, 某段库代码输出了乱码。如果我们不了解未定义行为, 我们可能会觉得是其他"正常"的问题, 例如UTF-8编码等; 反之如果我们了解, 就可以第一时间开始排查是否是内存的访问出了问题(大概率)。
- 又有人认为编译或运行时错误都会导致"确定"的结果, 从根本上否认了未定义行为的存在: 事实上, 结果并非是确定的。编译错误的结果可能随编译器而异, 而运行时错误的结果更是随运行环境/内存数据情况/操作系统而异。
	- 我们在[异常处理](<异常处理(Exception%20Handling).md>)中提到的除零错误就是个很好的运行时错误的例子。由于我们在`Windows`下运行，输出的错误码是`Windows`所定义的; 但如果换到`Linux`下, 输出的错误有可能完全不同。

实际上, 未定义行为的存在主要是因为编译器不同以及内存数据的不同。C++的内存不安全性在这里典型地体现了出来, 可以说, 正是由于我们的指针可以指向任意一个奇怪的地址, 奇怪的地址又包含未知的内容, 我们才会得到奇怪的输出。

### 常见的未定义行为有哪些呢?

如上所说, 如果我们在编写代码时足够小心, 未定义行为是可以直接避免的。但别人的代码我们就不那么肯定了。了解一个常见的未定义行为列表, 就像医院里的急救流程一样，包含它的特征、原因和处理方法, 将会给引用的第三方库或者别人的代码加上一道非常稳固的安全防线。

*注: 下面的列表将不定期更新, 直到所有可能的未定义行为都包含在其中为止(大概率可能不会...?)*

注2: 在剩下的内容中, 将使用UB(Undefined Behaviour, 即未定义行为的英文缩写)来指代未定义行为。

#### 1. 变量已声明, 但未赋值就使用

**一种触发方式**

```c++
// 触发变量未赋值就使用的 UB
void trigger_undefined_variable(){  
    int x;  
    int y = x + 8;  
    cout << y << endl;  
}
```

**特征**

`y`输出的值随编译器和`x`在声明时编译器给定的默认值而异。

**何时可能出现**

当我们看到一个变量的值超出范围或不符合预期(例如传入临界值(函数当作特殊情况处理的值)时输出的结果不符合特殊情况的特征), 表示可能出现此问题。

**如何解决**

给未赋值就使用的变量一个初值。

#### 2. 数组越界访问

**一种触发方式**

```c++
// 触发下标越界  
void trigger_array_access_out_of_bounds(){  
    int arr[5] = {1,2,3,4,5};  //特别写出长度为5, 便于观察  
    cout << arr[5] << endl;  
}
```

**特征**

`arr[5]`输出的值随编译器分配给数组最后一个元素的地址的下一个地址的内容而异。

> 我们可以使用调试器中的内存视图查看器来看到内存的分配情况, 例如`CLion`中调试器的内存视图。

**何时可能出现**

当我们看到一个数组访问的值和这个数组存放的内容明显不符时, 表示可能出现此问题。

**如何解决**

确保数组访问的下标在\[0, 数组长度-1\]范围内。

(*未完待续*)