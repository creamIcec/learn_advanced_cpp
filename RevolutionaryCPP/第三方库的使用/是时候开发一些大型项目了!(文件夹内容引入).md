
为了开发工程化的项目，我们需要完整的工具链。
此外，我们可能需要类似于`npm`或者`pip`这样的包管理器。

### 目前我们用的工具链是啥?

#### "原生"的工具链(各操作系统基本通用)

**构建系统**: `cmake`和`ninja`
**编译器**: `g++`

#### Windows专用

**开发套件**: `Desktop Development with C++` (从`Visual Studio Installer`中安装)
**编译器**: `VC++`

#### 问题是: 有包管理器吗?...

在`C/C++`的开发中，我们几乎没有听说过包管理器等概念。事实上，为了方便第三方库的引用，类似的"包管理器"从近10年才在`C++`的世界中出现(例如微软开源的`vcpkg`等)。如果从一般的包管理器的功能来"强行"类比的话:

##### `#include` 类似于 `import` 吗? 能否作为包管理的单位?

`#include`的存在形式和`import`大不相同。以我们常见的**重复包含**问题为例, 我们必须在每个头文件中添加下面的预处理宏来防止重复包含:

```c++
#program once
```

或者

```c++
#ifndef <某个符号A>
#define <A>

/*具体内容*/

#endif
```

也就是说, 我们需要手动去管理一个头文件可能被重复包含的情况, 构建系统不会自动防止它们被重复包含。这就和其他的`import`语句有很大的区别了(例如Javascript中的`import`)。

*注: 关于Javascript的`import`是如何工作的, 可以参考这篇非常生动直观的文章: [ES Modules a Cartoon Deep Dive](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)。简单来讲就是两条原则: 1) 当一个模块(module.js)被main.js包含时会先执行module.js的顶层代码, 再执行main.js的顶层代码; 2) 一个模块只在第一次被包含时才执行顶层代码, 如果多个文件包含了这个模块, 顶层代码只会执行一次。

##### 头文件有统一的来源吗? (中央仓库)

> C++发展简史: https://cplusplus.com/info/history/

显然是没有的。至于原因，每门语言的用途和发展历史各不相同, 对于`C++`来说，`C++`最开始的发明就是面向底层, 面向后端逻辑的, 因此一开始的大多数时候，大多数使用`C++`就是为了开发自己的应用程序, 很少涉及到调用外部逻辑。这就自然而然导致了下面的结果:

- 每个组织开发自己的不同用途的程序, 用于不同的底层平台, 加上语言本身面向底层: **没有跨平台基础**
- 语言本身出现时间非常早, 当时的软件开发还不是那么的工程化: **历史发展原因**

从`C++20`开始, `import`语句的使用似乎正在尝试改变这样一种已经持续了近50年的现状。不过, 由于各家分散, 底层不兼容的原因, `import`系统的使用仍然任重而道远。

##### 有方便的自动化管理吗?

由于我们仍然需要依赖`cmake`这样复杂的构建系统并且用它编写**全工具链**的分步骤指令, 我们暂时还没有看到非常方便的自动化管理。不过, `vcpkg`似乎为**链接**阶段提供了类似的“使用体验”, 使用一行指令就可以安装依赖库:

```bash
vcpkg install opencv
```

这种管理方式的出现无疑经过了非常长时间的发展而且是划时代的。至于`vcpkg`的具体工作原理, 我们暂时不做深究, 等我们尝试过一些第三方库的手动引用后再来看看`vcpkg`的用法。

#### 综上所述...

`C++`没有非常统一的包管理器。尽管出现了`vcpkg`和`canon`等名义上的包管理器, 语言本身是不包含包管理的机制的。正因如此, 大多数时候我们仍然需要手动管理第三方库的引用。

一言以蔽之:

> 一门面向底层开发, 因平台而异的语言, 很难形成统一的包管理体系。

另:

> 期待一下`import`的功能以后会如何发展吧:)


### 接下来

这个文件夹包含了我们所有对于第三方库的研究，包括他们的安装、构建和使用，以及中途遇到的各种大大小小的问题。

为了全面充分地了解第三方库的使用，我们将从以下底层领域中各自挑选出一个第三方库:

- 图像处理/计算机视觉: `OpenCV`
- 计算机图形/渲染引擎: `OpenGL`
- 音频处理: `libsoundio`
- 计算机网络: `asio`
- 游戏引擎: `acid`
- 人工智能: `pytorch`

这个文件夹的目的是通过列举尽可能多的库的使用方法，以期构建出对于`C++`中如何使用第三方库的更加全面的认识，从而构建隐性知识。

> *在无穷无尽的碎片知识中，我们总能探索出一条通向更深层理解的路。*
